{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tsrc - managing multiple git repositories \u00b6 What it is \u00b6 tsrc is a command-line tool that helps you manage several git repositories. We use it at tanker.io because: We have a small, versatile team of developers We use several programming languages We need a single source of truth for the list of repositories we want to work on: their URL, branch and locations should be the same across all the team None on the many existing solutions did fully match our needs (see the FAQ for more details) In addition, tsrc has some support for interaction with GitLab and makes handling merge requests from the command line possible. Installing tsrc \u00b6 tsrc is compatible with Python 3.4 or higher. It is available on pypi and can be installed with pip : Linux \u00b6 $ pip3 install tsrc --user # Make sure ~/.local/bin is in your PATH macOS \u00b6 $ pip3 install tsrc --user # Make sure ~/Library/Python/3.x/bin is in your PATH Windows \u00b6 Install latest Python3 from python.org/downloads , open cmd.exe and run: $ pip3 install tsrc Next steps \u00b6 If tsrc is installed properly (check by running tsrc version ), feel free to proceed to basic usage .","title":"Home"},{"location":"#tsrc_-_managing_multiple_git_repositories","text":"","title":"tsrc - managing multiple git repositories"},{"location":"#what_it_is","text":"tsrc is a command-line tool that helps you manage several git repositories. We use it at tanker.io because: We have a small, versatile team of developers We use several programming languages We need a single source of truth for the list of repositories we want to work on: their URL, branch and locations should be the same across all the team None on the many existing solutions did fully match our needs (see the FAQ for more details) In addition, tsrc has some support for interaction with GitLab and makes handling merge requests from the command line possible.","title":"What it is"},{"location":"#installing_tsrc","text":"tsrc is compatible with Python 3.4 or higher. It is available on pypi and can be installed with pip :","title":"Installing tsrc"},{"location":"#linux","text":"$ pip3 install tsrc --user # Make sure ~/.local/bin is in your PATH","title":"Linux"},{"location":"#macos","text":"$ pip3 install tsrc --user # Make sure ~/Library/Python/3.x/bin is in your PATH","title":"macOS"},{"location":"#windows","text":"Install latest Python3 from python.org/downloads , open cmd.exe and run: $ pip3 install tsrc","title":"Windows"},{"location":"#next_steps","text":"If tsrc is installed properly (check by running tsrc version ), feel free to proceed to basic usage .","title":"Next steps"},{"location":"changelog/","text":"v0.9.2 - (2019-09-30) \u00b6 Additional bug fix for #165 - the fix in 0.9.1 was incomplete Improve error message when trying to use non-supported GitLab features (like using tsrc push --reviewer on GitLab Community Edition) v0.9.1 - (2019-09-23) \u00b6 Improve error message when tsrc foreach fails to start the process. Suggested by @dlewis-ald in #163 Fix crash when finding reviewers for a GitLab project not in a group. Reported by @irizzant in #165 v0.9.0 - (2019-08-13) \u00b6 Add support for GitHub Enterprise: See the relevant documentation for details - patch by @sdavids13. Improve error message when using creating a merge request in a GitLab repository when the token cannot be found in the tsrc configuration file. Fix #158 Fix crash when running tsrc status on a workspace with missing repositories (#160) - reported by @blastrock v0.8.0 - (2019-08-12) \u00b6 Implement tsrc sync --force . Currently all it does is running git fetch --force on all repositories. Use with caution. See #152 for details. v0.7.1 - (2019-08-02) \u00b6 Fix crash in tsrc sync when the repo configuration in the manifest contained neither an URL nor a remote. tsrc now aborts as soon as the misconfiguration of the manifest is detected (Reported by @jongep86) v0.7.0 (2019-07-08) \u00b6 Add a --file option to tsrc init so that manifest can be read from a custom path in the file system Remove support for Python 3.4 Switch from xdg to pyxdg Format the code with black v0.6.6 (2019-04-02) \u00b6 Remove raw HTML from README.rst v0.6.5 (2019-04-0) \u00b6 Use codecov.io to measure coveage Prettify README v0.6.4 (2019-01-07) \u00b6 Remove support for Python 3.3. Use new and shiny cli-ui package instead of old python-cli-ui . v0.6.3 (2018-11-04) \u00b6 GitHub organization is now TankerHQ We now use dmenv for dependencies management v0.6.2 (2018-10-19) \u00b6 Fix crash when using tsrc push on a GitHub repository for the first time. v0.6.1 (2018-10-10) \u00b6 Fix weird output when configuring remotes. v0.6.0 (2018-10-09) \u00b6 Highlights \u00b6 Add support for multiple remotes \u00b6 # still valid (implicit 'origin' remote) src: foo url: git@github.com/foo # also valid (two explicit remotes) src: fooo remotes: - { name: origin, url: git@github.com:john/foo } - { name: upstream, url: git@github.com:foo/foo} # not valid (ambiguous) src: foo url: git@github.com:john/foo remotes: - { name: upstream, url: git@github.com:foo/foo } Thanks @tst2005 and @cgestes for their help with the configuration format. tsrc foreach \u00b6 tsrc foreach : add a --group option to select the repositories to run the command on. Fix #40 Other fixes \u00b6 Fix #113 : do not hide branch when showing tag status. Add support for Python 3.7 v0.5.0 (2018-08-14) \u00b6 Add support for setting approvers with the -r,--approvers option in tsrc push (GitLab Enterprise Edition only). v0.4.1 (2018-04-27) \u00b6 Fixed regression: tsrc push was no longer able to create a merge request on GitLab if --target was not set. v0.4.0 (2018-04-26) \u00b6 Highlights \u00b6 Preliminary GitHub support tsrc push : new features and bug fixes Improved fixed reference handling Support for shallow clones See below for the details. Preliminary GitHub support \u00b6 Added support for creating merge requests on GitHub. No configuration required. Just make sure you are using tsrc from a repository which has a URL starting with git@github.com . tsrc will prompt you once for your login and password and then store an API token. Afterwards, you'll be able to use tsrc push to: Create a pull request (or update it if it already exists) Assign people to the request (with the -a/--assignee option) Request reviewers (with the --reviewers option) Merge the pull request (with the --merge option) This change has no impact if you were already using GitLab . tsrc push : new features and bug fixes \u00b6 Add --close option. Breaking change : -m/--message option is gone, use --title instead. There's a concept of \"description\" or \"message\" for pull requests and merge requests, but the value of the option was only used to update the title , so it had to be renamed. Do not assume local and remote tracking branch have the same name. Allow using tsrc push <local>:<remote> to explicitly specify local and remote branch names. Fix bugs when target is not specified on the command line. See this commit for details. Fix missing merge requests in tsrc push (see issue #80 ). Patch by @maximerety. Improve fixed reference handling \u00b6 Breaking change : Instead of using fixed_ref in the manifest, you should now use tag or sha1 : old : repos: - src: git@example.com/foo fixed_ref: 42a70 new : repos: - src: git@example.com/foo tag: v0.1 See the dedicated section about manifest format and the #57 pull request discussion for the details. This allow us to implement different behaviors depending on whether or not the fixed ref is a tag or just a sha1. Support for shallow clones \u00b6 To save time and space, you can use tsrc init --shallow to only have shallow clones in your workspace. Note that due to limitations in git itself, the shallow option cannot be used with a fixed SHA1. If you need this, prefer using a tag instead. Misc \u00b6 Organization TankerApp was renamed to TankerHQ . New urls are: github.com/TankerHQ/tsrc for the git repository TankerHQ.github.io/tsrc for the documentation We now use pipenv for dependency handling. v0.3.2 (2017-11-02) \u00b6 Improve tsrc status to handle tags. Patch by @arnaudgelas. Fix crash when running tsrc version . v0.3.1 (2017-10-06) \u00b6 Improve tsrc status output. Now also shows number of commits ahead and behind, and display a short SHA-1 when not on any branch. Initial patch by @arnaudgelas. v0.3.0 (2017-09-22) \u00b6 Breaking change : Add support for groups (#30). Reported by @arnaudgelas. See the dedicated section about manifest format for details. Upgrading from v0.2.4 : To upgrade from an older version of tsrc , you should re-run tsrc init with the correct url: # Check manifest URL: $ cd <workspace>/.tsrc/manifest $ git remote get-url origin # Note the url, for instance ssh://git@example.com:manifest.git $ cd <workspace> $ tsrc init <manifest-url> This is required to create the <workspace>/.tsrc/manifest.yml file which is later used by tsrc sync and other commands. v0.2.4 (2017-07-13) \u00b6 tsrc push --assignee : fix when there are more than 50 GitLab users (#25). Reported by @arnaudgelas v0.2.3 (2017-09-01) \u00b6 Split user interface functionality into its own project: python-cli-ui . Add --quiet and --color global options. v0.2.2 (2017-08-22) \u00b6 Bug fix release. tsrc init : Fix crash when a repository is empty (#17). Reported by @nicolasbrechet tsrc push : Fix rude message when credentials are missing (#20). Reported by @cgestes v0.2.1 (2017-08-10) \u00b6 Packaging fixes. v0.2.0 (2017-08-09) \u00b6 Support for specifying custom branches in the manifest Support for specifying fixed refs (tags or hashes) in the manifest New syntax is: repos: - src: foo url: git@gitlab.com:proj/foo branch: next - src: bar url: git@gitlab.com:proj/bar branch: master fixed_ref: v0.1 Note that branch is still required. You can now skip the dest part of the copy section if src and dest are equal: copy: - src:foo # same thing as copy: - src: foo dest: foo v0.1.4 (2017-08-04) \u00b6 Support for Python 3.3, 3.4, 3.5 and 3.6 v0.1.1 (2017-08-02) \u00b6 First public release","title":"Changelog"},{"location":"changelog/#v092_-_2019-09-30","text":"Additional bug fix for #165 - the fix in 0.9.1 was incomplete Improve error message when trying to use non-supported GitLab features (like using tsrc push --reviewer on GitLab Community Edition)","title":"v0.9.2 - (2019-09-30)"},{"location":"changelog/#v091_-_2019-09-23","text":"Improve error message when tsrc foreach fails to start the process. Suggested by @dlewis-ald in #163 Fix crash when finding reviewers for a GitLab project not in a group. Reported by @irizzant in #165","title":"v0.9.1 - (2019-09-23)"},{"location":"changelog/#v090_-_2019-08-13","text":"Add support for GitHub Enterprise: See the relevant documentation for details - patch by @sdavids13. Improve error message when using creating a merge request in a GitLab repository when the token cannot be found in the tsrc configuration file. Fix #158 Fix crash when running tsrc status on a workspace with missing repositories (#160) - reported by @blastrock","title":"v0.9.0 - (2019-08-13)"},{"location":"changelog/#v080_-_2019-08-12","text":"Implement tsrc sync --force . Currently all it does is running git fetch --force on all repositories. Use with caution. See #152 for details.","title":"v0.8.0 - (2019-08-12)"},{"location":"changelog/#v071_-_2019-08-02","text":"Fix crash in tsrc sync when the repo configuration in the manifest contained neither an URL nor a remote. tsrc now aborts as soon as the misconfiguration of the manifest is detected (Reported by @jongep86)","title":"v0.7.1 - (2019-08-02)"},{"location":"changelog/#v070_2019-07-08","text":"Add a --file option to tsrc init so that manifest can be read from a custom path in the file system Remove support for Python 3.4 Switch from xdg to pyxdg Format the code with black","title":"v0.7.0 (2019-07-08)"},{"location":"changelog/#v066_2019-04-02","text":"Remove raw HTML from README.rst","title":"v0.6.6 (2019-04-02)"},{"location":"changelog/#v065_2019-04-0","text":"Use codecov.io to measure coveage Prettify README","title":"v0.6.5 (2019-04-0)"},{"location":"changelog/#v064_2019-01-07","text":"Remove support for Python 3.3. Use new and shiny cli-ui package instead of old python-cli-ui .","title":"v0.6.4 (2019-01-07)"},{"location":"changelog/#v063_2018-11-04","text":"GitHub organization is now TankerHQ We now use dmenv for dependencies management","title":"v0.6.3 (2018-11-04)"},{"location":"changelog/#v062_2018-10-19","text":"Fix crash when using tsrc push on a GitHub repository for the first time.","title":"v0.6.2 (2018-10-19)"},{"location":"changelog/#v061_2018-10-10","text":"Fix weird output when configuring remotes.","title":"v0.6.1 (2018-10-10)"},{"location":"changelog/#v060_2018-10-09","text":"","title":"v0.6.0 (2018-10-09)"},{"location":"changelog/#highlights","text":"","title":"Highlights"},{"location":"changelog/#add_support_for_multiple_remotes","text":"# still valid (implicit 'origin' remote) src: foo url: git@github.com/foo # also valid (two explicit remotes) src: fooo remotes: - { name: origin, url: git@github.com:john/foo } - { name: upstream, url: git@github.com:foo/foo} # not valid (ambiguous) src: foo url: git@github.com:john/foo remotes: - { name: upstream, url: git@github.com:foo/foo } Thanks @tst2005 and @cgestes for their help with the configuration format.","title":"Add support for multiple remotes"},{"location":"changelog/#tsrc_foreach","text":"tsrc foreach : add a --group option to select the repositories to run the command on. Fix #40","title":"tsrc foreach"},{"location":"changelog/#other_fixes","text":"Fix #113 : do not hide branch when showing tag status. Add support for Python 3.7","title":"Other fixes"},{"location":"changelog/#v050_2018-08-14","text":"Add support for setting approvers with the -r,--approvers option in tsrc push (GitLab Enterprise Edition only).","title":"v0.5.0 (2018-08-14)"},{"location":"changelog/#v041_2018-04-27","text":"Fixed regression: tsrc push was no longer able to create a merge request on GitLab if --target was not set.","title":"v0.4.1 (2018-04-27)"},{"location":"changelog/#v040_2018-04-26","text":"","title":"v0.4.0 (2018-04-26)"},{"location":"changelog/#highlights_1","text":"Preliminary GitHub support tsrc push : new features and bug fixes Improved fixed reference handling Support for shallow clones See below for the details.","title":"Highlights"},{"location":"changelog/#preliminary_github_support","text":"Added support for creating merge requests on GitHub. No configuration required. Just make sure you are using tsrc from a repository which has a URL starting with git@github.com . tsrc will prompt you once for your login and password and then store an API token. Afterwards, you'll be able to use tsrc push to: Create a pull request (or update it if it already exists) Assign people to the request (with the -a/--assignee option) Request reviewers (with the --reviewers option) Merge the pull request (with the --merge option) This change has no impact if you were already using GitLab .","title":"Preliminary GitHub support"},{"location":"changelog/#tsrc_push_new_features_and_bug_fixes","text":"Add --close option. Breaking change : -m/--message option is gone, use --title instead. There's a concept of \"description\" or \"message\" for pull requests and merge requests, but the value of the option was only used to update the title , so it had to be renamed. Do not assume local and remote tracking branch have the same name. Allow using tsrc push <local>:<remote> to explicitly specify local and remote branch names. Fix bugs when target is not specified on the command line. See this commit for details. Fix missing merge requests in tsrc push (see issue #80 ). Patch by @maximerety.","title":"tsrc push: new features and bug fixes"},{"location":"changelog/#improve_fixed_reference_handling","text":"Breaking change : Instead of using fixed_ref in the manifest, you should now use tag or sha1 : old : repos: - src: git@example.com/foo fixed_ref: 42a70 new : repos: - src: git@example.com/foo tag: v0.1 See the dedicated section about manifest format and the #57 pull request discussion for the details. This allow us to implement different behaviors depending on whether or not the fixed ref is a tag or just a sha1.","title":"Improve fixed reference handling"},{"location":"changelog/#support_for_shallow_clones","text":"To save time and space, you can use tsrc init --shallow to only have shallow clones in your workspace. Note that due to limitations in git itself, the shallow option cannot be used with a fixed SHA1. If you need this, prefer using a tag instead.","title":"Support for shallow clones"},{"location":"changelog/#misc","text":"Organization TankerApp was renamed to TankerHQ . New urls are: github.com/TankerHQ/tsrc for the git repository TankerHQ.github.io/tsrc for the documentation We now use pipenv for dependency handling.","title":"Misc"},{"location":"changelog/#v032_2017-11-02","text":"Improve tsrc status to handle tags. Patch by @arnaudgelas. Fix crash when running tsrc version .","title":"v0.3.2 (2017-11-02)"},{"location":"changelog/#v031_2017-10-06","text":"Improve tsrc status output. Now also shows number of commits ahead and behind, and display a short SHA-1 when not on any branch. Initial patch by @arnaudgelas.","title":"v0.3.1 (2017-10-06)"},{"location":"changelog/#v030_2017-09-22","text":"Breaking change : Add support for groups (#30). Reported by @arnaudgelas. See the dedicated section about manifest format for details. Upgrading from v0.2.4 : To upgrade from an older version of tsrc , you should re-run tsrc init with the correct url: # Check manifest URL: $ cd <workspace>/.tsrc/manifest $ git remote get-url origin # Note the url, for instance ssh://git@example.com:manifest.git $ cd <workspace> $ tsrc init <manifest-url> This is required to create the <workspace>/.tsrc/manifest.yml file which is later used by tsrc sync and other commands.","title":"v0.3.0 (2017-09-22)"},{"location":"changelog/#v024_2017-07-13","text":"tsrc push --assignee : fix when there are more than 50 GitLab users (#25). Reported by @arnaudgelas","title":"v0.2.4 (2017-07-13)"},{"location":"changelog/#v023_2017-09-01","text":"Split user interface functionality into its own project: python-cli-ui . Add --quiet and --color global options.","title":"v0.2.3 (2017-09-01)"},{"location":"changelog/#v022_2017-08-22","text":"Bug fix release. tsrc init : Fix crash when a repository is empty (#17). Reported by @nicolasbrechet tsrc push : Fix rude message when credentials are missing (#20). Reported by @cgestes","title":"v0.2.2 (2017-08-22)"},{"location":"changelog/#v021_2017-08-10","text":"Packaging fixes.","title":"v0.2.1 (2017-08-10)"},{"location":"changelog/#v020_2017-08-09","text":"Support for specifying custom branches in the manifest Support for specifying fixed refs (tags or hashes) in the manifest New syntax is: repos: - src: foo url: git@gitlab.com:proj/foo branch: next - src: bar url: git@gitlab.com:proj/bar branch: master fixed_ref: v0.1 Note that branch is still required. You can now skip the dest part of the copy section if src and dest are equal: copy: - src:foo # same thing as copy: - src: foo dest: foo","title":"v0.2.0 (2017-08-09)"},{"location":"changelog/#v014_2017-08-04","text":"Support for Python 3.3, 3.4, 3.5 and 3.6","title":"v0.1.4 (2017-08-04)"},{"location":"changelog/#v011_2017-08-02","text":"First public release","title":"v0.1.1 (2017-08-02)"},{"location":"code-manifesto/","text":"Basics \u00b6 We use flake8 to enforce a coding style matching PEP8 . In addition, every text file must be pushed using UNIX line endings. (On Windows, you are advised to set core.autocrlf to true in your git config file.) Pet peeves \u00b6 Prefer double quotes for string literals: # Yes def bar(): \"\"\" bar stuff \"\"\" a = \"foo\" # No def bar(): ''' bar stuf ''' a = 'foo' # Exception my_str = 'It contains some \"quotes\" inside' Use the fact that empty data structures are falsy: # Yes if not errors: ... # No if len(errors) == 0: ... Do not use + to build strings. Use format() , % instead, or \"f-strings\" if you only want the code to work with Python >= 3.6: # Yes message = \"Welcome, {}!\".format(name) message = \"Welcome, %s!\" % name message = f\"Welcome {name}!\" # No message = \"Welcome, \" + name + \"!\" # Okayish with_ext = name + \".txt\" Use textwrap.dedent() to build nice-looking multi-lines strings: # Yes def foo(): long_message = textwrap.dedent(\"\"\"\\ first line second line third line\"\"\") # No def foo(): long_message = \"\"\"\\ first line second line third line \"\"\" Do not initialize several variables on the same line, unless they come from a tuple (for instance the return of a function, or a iteration on a directory) # Yes ok, mess = run_command() for test_result in test_results: outcome, message = res # No foo, bar = False, \"\" class Foo: self.bar, self.baz = None, True Do not use conditional expressions. The order is not the same as the ternary operator in C++ and Javascript, so it should be avoided: # Yes if foo: a = \"ok\" else: a = \"nope\" # No: a = \"ok\" if foo else \"nope\" Use if ... in ... when you can: # Yes if value in [\"option1\", \"option2\"]: ... # No if value == \"option1\" or value == \"option2\" ... Doc strings and comments \u00b6 First off, bad comments are worse that no comments. Also note that you should use comments to explain why , never what . If the what is no clear, it means the behavior of the function or method cannot be easily understood by reading implementation, and so you should fix the implementation instead. In conclusion, use comments and doc strings sparingly: that way, they will not rot and they will stay useful. Collections \u00b6 Use .extend() instead of += to concatenate lists: # Yes list_1.extend(list_2) # No list_1 += list_2 Use explicit methods to initialize lists and dictionaries. The code is more readable, and you have to use set() to initialize sets anyway: # Yes my_list = list() my_dict = dict() # No my_list = [] my_dict = {} Also use explicit call to list() in order to make a copy: # Yes my_copy = list(my_list) # Also yes: my_copy = copy.copy(my_list) # No my_copy = my_list[:] Use list comprehensions instead of loops and \"functional\" methods: # Yes my_list = [foo(x) for x in other_list] # No my_list = list() for x in other_list: x.append(foo(x)) # Also no my_list = map(foo, other_list) # Yes even_nums = [x for x in nums if is_even(x)] # No even_nums = filter(is_even, nums) Use iterable syntax instead of building an explicit list: # Yes max(len(x) for x in myiterable) # No max([len(x) for x in myiterable]) Use plural names for collections. This has the nice benefit of allowing you to have meaningful loop names: for result in results: # do something with result Functions \u00b6 Prefer using keyword-only parameters when possible: # Yes # If the parameter needs a default value: def foo(bar, *, spam=True): ... # If it does not: def foo(bar, *, spam): ... # No def foo(bar, spam=True): ... If you use the last form, Python will let you use foo(42, False) , and set spam to False. This can cause problems if someone ever changes the foo function and adds a new optional argument before spam : def foo(bar, eggs=False, spam=Tue): ... After such a change, the line foo(42, False) which used to call foo with spam=False now calls foo with bar=False and spam=True , leading to all kinds of interesting bugs. Exception to this rule: when the keyword is obvious and will not change: def get(value, default=None): ... Imports \u00b6 For any foo.py file, import foo must never fail, unless there is a necessary module that could not be found. Do not catch ImportError unless it is necessary, for instance to deal with optional dependencies. import required_module HAS_NICE_FEATURE = True try: import nicelib except ImportError: HAS_NICE_FEATURE = False #... if HAS_NICE_FEATURE: #.... Importing Python files should never cause side effects. It's OK to initialize global variables, but you should never call functions outside a if __name__ == main() block . Prefer using fully-qualified imports and names: # Yes import foo.bar my_bar = foo.bar.Bar() # No from foo import bar my_bar = bar.Bar() Note We allow a few exceptions like from path import Path or importing classes directory in tests. Use your best judgement. Classes \u00b6 When you want to make sure a class follows an interface, use abc.ABCMeta instead of raising NotImplementedError . This way you get the error when the class is instantiated instead of when the method is called. # Yes class AbstractFoo(metaclass=abc.ABCMeta): @abc.abstractmethod def foo(self): pass # No class AbstractFoo: def foo(self): raise NotImplementedError() Make sure to use properties when relevant, instead of get_ methods. # Yes class Person: def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name @property def full_name(self): return \"{} {}\".format(self.first_name, self.last_name) # No: class Foo: def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name self.full_name = \"{} {}\".format(self.first_name, self.last_name) For instance, here: full_name is read-only The attribute is automatically updated if first_name changes after the object is initialized. Note that get_ methods are OK if they do more than simple computations (expensive in time or size, throwing exceptions ...) File paths \u00b6 If you are manipulating filenames, use the path.py library and suffix the variable by _path . Avoid using os.path or shutil methods when path.py is better. # Yes work_path = Path(\"foo/work\") work_path.mkdir_p() foo_path = work_path / \"foo.txt\" foo_path.write_text(\"this is bar\") # No work_path = os.path.join(foo, \"work\") os.path.mkdir(work_path, exist_ok=True) foo_path = os.path.join(work_path, \"foo.txt\") with open(foo_path, \"w\") as fileobj: fileobj.write(\"this is foo\") Error handling \u00b6 All exceptions raised from within tsrc should derive from tsrc.Error . When using external code (from the standard library or a third-party library), you should catch the exceptions and optionally re-raise them. Output messages to the user \u00b6 Do not use print , use python-cli-ui functions instead. This makes it easier to distinguish between real messages and the throw-away print statements you add for debugging. Also, using \"high-level\" methods such as ui.info_1() or ui.warning() will make it easier to have a consistent user interface. Tests \u00b6 When writing assertions, use the form assert <actual> == <expected> : # Yes def test_foo(): assert foo(42) == True def test_big_stuff(): actual_result = ... expected_result = ... assert actual_result == expected_result # No def test_foo(): assert True == foo(42) def test_big_stuff(): actual_result = ... expected_result = ... assert expected_result == actual_result Rationale: The assert(expected, actual) convention comes from JUnit but we are not writing Java code, and besides, the assert(actual, expected) convention also exists in other tools. pytest does not really care, but we prefer being consistent in all tests. It's a bit closer to what you would say in English: \"Assert that the result of foo() is 42\" .","title":"Code manifesto"},{"location":"code-manifesto/#basics","text":"We use flake8 to enforce a coding style matching PEP8 . In addition, every text file must be pushed using UNIX line endings. (On Windows, you are advised to set core.autocrlf to true in your git config file.)","title":"Basics"},{"location":"code-manifesto/#pet_peeves","text":"Prefer double quotes for string literals: # Yes def bar(): \"\"\" bar stuff \"\"\" a = \"foo\" # No def bar(): ''' bar stuf ''' a = 'foo' # Exception my_str = 'It contains some \"quotes\" inside' Use the fact that empty data structures are falsy: # Yes if not errors: ... # No if len(errors) == 0: ... Do not use + to build strings. Use format() , % instead, or \"f-strings\" if you only want the code to work with Python >= 3.6: # Yes message = \"Welcome, {}!\".format(name) message = \"Welcome, %s!\" % name message = f\"Welcome {name}!\" # No message = \"Welcome, \" + name + \"!\" # Okayish with_ext = name + \".txt\" Use textwrap.dedent() to build nice-looking multi-lines strings: # Yes def foo(): long_message = textwrap.dedent(\"\"\"\\ first line second line third line\"\"\") # No def foo(): long_message = \"\"\"\\ first line second line third line \"\"\" Do not initialize several variables on the same line, unless they come from a tuple (for instance the return of a function, or a iteration on a directory) # Yes ok, mess = run_command() for test_result in test_results: outcome, message = res # No foo, bar = False, \"\" class Foo: self.bar, self.baz = None, True Do not use conditional expressions. The order is not the same as the ternary operator in C++ and Javascript, so it should be avoided: # Yes if foo: a = \"ok\" else: a = \"nope\" # No: a = \"ok\" if foo else \"nope\" Use if ... in ... when you can: # Yes if value in [\"option1\", \"option2\"]: ... # No if value == \"option1\" or value == \"option2\" ...","title":"Pet peeves"},{"location":"code-manifesto/#doc_strings_and_comments","text":"First off, bad comments are worse that no comments. Also note that you should use comments to explain why , never what . If the what is no clear, it means the behavior of the function or method cannot be easily understood by reading implementation, and so you should fix the implementation instead. In conclusion, use comments and doc strings sparingly: that way, they will not rot and they will stay useful.","title":"Doc strings and comments"},{"location":"code-manifesto/#collections","text":"Use .extend() instead of += to concatenate lists: # Yes list_1.extend(list_2) # No list_1 += list_2 Use explicit methods to initialize lists and dictionaries. The code is more readable, and you have to use set() to initialize sets anyway: # Yes my_list = list() my_dict = dict() # No my_list = [] my_dict = {} Also use explicit call to list() in order to make a copy: # Yes my_copy = list(my_list) # Also yes: my_copy = copy.copy(my_list) # No my_copy = my_list[:] Use list comprehensions instead of loops and \"functional\" methods: # Yes my_list = [foo(x) for x in other_list] # No my_list = list() for x in other_list: x.append(foo(x)) # Also no my_list = map(foo, other_list) # Yes even_nums = [x for x in nums if is_even(x)] # No even_nums = filter(is_even, nums) Use iterable syntax instead of building an explicit list: # Yes max(len(x) for x in myiterable) # No max([len(x) for x in myiterable]) Use plural names for collections. This has the nice benefit of allowing you to have meaningful loop names: for result in results: # do something with result","title":"Collections"},{"location":"code-manifesto/#functions","text":"Prefer using keyword-only parameters when possible: # Yes # If the parameter needs a default value: def foo(bar, *, spam=True): ... # If it does not: def foo(bar, *, spam): ... # No def foo(bar, spam=True): ... If you use the last form, Python will let you use foo(42, False) , and set spam to False. This can cause problems if someone ever changes the foo function and adds a new optional argument before spam : def foo(bar, eggs=False, spam=Tue): ... After such a change, the line foo(42, False) which used to call foo with spam=False now calls foo with bar=False and spam=True , leading to all kinds of interesting bugs. Exception to this rule: when the keyword is obvious and will not change: def get(value, default=None): ...","title":"Functions"},{"location":"code-manifesto/#imports","text":"For any foo.py file, import foo must never fail, unless there is a necessary module that could not be found. Do not catch ImportError unless it is necessary, for instance to deal with optional dependencies. import required_module HAS_NICE_FEATURE = True try: import nicelib except ImportError: HAS_NICE_FEATURE = False #... if HAS_NICE_FEATURE: #.... Importing Python files should never cause side effects. It's OK to initialize global variables, but you should never call functions outside a if __name__ == main() block . Prefer using fully-qualified imports and names: # Yes import foo.bar my_bar = foo.bar.Bar() # No from foo import bar my_bar = bar.Bar() Note We allow a few exceptions like from path import Path or importing classes directory in tests. Use your best judgement.","title":"Imports"},{"location":"code-manifesto/#classes","text":"When you want to make sure a class follows an interface, use abc.ABCMeta instead of raising NotImplementedError . This way you get the error when the class is instantiated instead of when the method is called. # Yes class AbstractFoo(metaclass=abc.ABCMeta): @abc.abstractmethod def foo(self): pass # No class AbstractFoo: def foo(self): raise NotImplementedError() Make sure to use properties when relevant, instead of get_ methods. # Yes class Person: def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name @property def full_name(self): return \"{} {}\".format(self.first_name, self.last_name) # No: class Foo: def __init__(self, first_name, last_name): self.first_name = first_name self.last_name = last_name self.full_name = \"{} {}\".format(self.first_name, self.last_name) For instance, here: full_name is read-only The attribute is automatically updated if first_name changes after the object is initialized. Note that get_ methods are OK if they do more than simple computations (expensive in time or size, throwing exceptions ...)","title":"Classes"},{"location":"code-manifesto/#file_paths","text":"If you are manipulating filenames, use the path.py library and suffix the variable by _path . Avoid using os.path or shutil methods when path.py is better. # Yes work_path = Path(\"foo/work\") work_path.mkdir_p() foo_path = work_path / \"foo.txt\" foo_path.write_text(\"this is bar\") # No work_path = os.path.join(foo, \"work\") os.path.mkdir(work_path, exist_ok=True) foo_path = os.path.join(work_path, \"foo.txt\") with open(foo_path, \"w\") as fileobj: fileobj.write(\"this is foo\")","title":"File paths"},{"location":"code-manifesto/#error_handling","text":"All exceptions raised from within tsrc should derive from tsrc.Error . When using external code (from the standard library or a third-party library), you should catch the exceptions and optionally re-raise them.","title":"Error handling"},{"location":"code-manifesto/#output_messages_to_the_user","text":"Do not use print , use python-cli-ui functions instead. This makes it easier to distinguish between real messages and the throw-away print statements you add for debugging. Also, using \"high-level\" methods such as ui.info_1() or ui.warning() will make it easier to have a consistent user interface.","title":"Output messages to the user"},{"location":"code-manifesto/#tests","text":"When writing assertions, use the form assert <actual> == <expected> : # Yes def test_foo(): assert foo(42) == True def test_big_stuff(): actual_result = ... expected_result = ... assert actual_result == expected_result # No def test_foo(): assert True == foo(42) def test_big_stuff(): actual_result = ... expected_result = ... assert expected_result == actual_result Rationale: The assert(expected, actual) convention comes from JUnit but we are not writing Java code, and besides, the assert(actual, expected) convention also exists in other tools. pytest does not really care, but we prefer being consistent in all tests. It's a bit closer to what you would say in English: \"Assert that the result of foo() is 42\" .","title":"Tests"},{"location":"contrib/","text":"Development \u00b6 All the development happens on GitHub . Outcome of discussions among maintainers and users of the software are tracked in the wiki . Reporting bugs and suggesting new features \u00b6 Feel free to use the GitHub's bug tracker to open issues. If you are reporting a bug, please provide the following information: tsrc version Details about your environment (operating system, Python version) The exact command you run The full output Doing so will ensure we can investigate your bug right away. Suggesting changes \u00b6 You are free to open a pull request on GitHub for any feature you'd like. Before opening a merge request, please read the code manifesto . Note that for your merge request to be accepted, we'll ask that: You follow indications from the code manifesto All existing linters pass All existing tests run The new feature comes with appropriate tests See the .travis.yml file to see what exactly what commands are run and the Python versions we support. Also, if relevant, you will need to: update the changelog (in docs/changelog.md ) update the documentation if required Finally, feel free to add your name in the THANKS file ;) Checking your changes \u00b6 Install latest dmenv version. Install development and documentation dependencies: $ dmenv install Finally, run: $ source \"$(dmenv show:venv_path)/bin/activate\" $ python ci/ci.py Adding documentation \u00b6 Follow the steps from the above section to setup your python environment Launch the development server locally: $ dmenv run mkdocs serve Edit the markdown files from the docs/ folder and review the changes in your browser Finally, submit your changes by opening a pull request on GitHub","title":"Contributing"},{"location":"contrib/#development","text":"All the development happens on GitHub . Outcome of discussions among maintainers and users of the software are tracked in the wiki .","title":"Development"},{"location":"contrib/#reporting_bugs_and_suggesting_new_features","text":"Feel free to use the GitHub's bug tracker to open issues. If you are reporting a bug, please provide the following information: tsrc version Details about your environment (operating system, Python version) The exact command you run The full output Doing so will ensure we can investigate your bug right away.","title":"Reporting bugs and suggesting new features"},{"location":"contrib/#suggesting_changes","text":"You are free to open a pull request on GitHub for any feature you'd like. Before opening a merge request, please read the code manifesto . Note that for your merge request to be accepted, we'll ask that: You follow indications from the code manifesto All existing linters pass All existing tests run The new feature comes with appropriate tests See the .travis.yml file to see what exactly what commands are run and the Python versions we support. Also, if relevant, you will need to: update the changelog (in docs/changelog.md ) update the documentation if required Finally, feel free to add your name in the THANKS file ;)","title":"Suggesting changes"},{"location":"contrib/#checking_your_changes","text":"Install latest dmenv version. Install development and documentation dependencies: $ dmenv install Finally, run: $ source \"$(dmenv show:venv_path)/bin/activate\" $ python ci/ci.py","title":"Checking your changes"},{"location":"contrib/#adding_documentation","text":"Follow the steps from the above section to setup your python environment Launch the development server locally: $ dmenv run mkdocs serve Edit the markdown files from the docs/ folder and review the changes in your browser Finally, submit your changes by opening a pull request on GitHub","title":"Adding documentation"},{"location":"faq/","text":"Why not Python2 support? \u00b6 We believe Python2 is an inferior language than Python3, and we use many Python3 features to make the code more readable and robust. Plus Python2.7 supports ends in 2020 . Why not repo? \u00b6 We used repo for a while, but found that tsrc had both a better command line API and a nicer output. On a less subjective level: Good support for Windows (no need for CygWin or anything like that) GitLab support (automate working with merge requests) Lastly, tsrc tries hard to never do any destructive operation or unexpected actions. For instance, tsrc never puts you in a \"detached HEAD\" state, nor does automatic rebases. It also never touches dirty repos. This is achieved by using mostly 'porcelain' commands from git, instead of relying on plumbings internals. Also (and this matters a lot if you think about contribution): Comprehensive test suite Uses PEP8 coding style Written in Python 3, not Python 2 Here are a few features present in repo that are missing from tsrc (but may be implemented in the future) Cloning several repositories in parallel Support for other hosting services such as gerrit or github Why not git-subrepo, mu-repo, or gr? \u00b6 All this projects are fine but did not match our needs: git-subrepo squashes commits, and we prefer having normal clones everywhere. mu-repo is nice and contains an interesting dependency management feature, but currently we do not need this complexity. In any case, now that the whole team is using tsrc all the time, it's likely we'll keep using tsrc in the future. Why not git submodule? \u00b6 It's all about workflow. With git-submodule , you have a 'parent' repository and you freeze the state of the 'children' repositories to a specific commit. It's useful when you want to re-build a library you've forked when you build your main project, or when you have a library or build tools you want to factorize across repositories: this means that each 'parent' repository can have its children on any commit they want. With tsrc , all repositories are equal, and what you do instead is to make sure all the branches (or tags) are consistent across repositories. For instance, if you have foo and bar , you are going to make sure the 'master' branch of foo is always compatible to the 'master' branch of bar . Or if you want to go back to the state of the '0.42' release, you will run: tsrc foreach -- git reset --hard v0.42 . Note that since tsrc 0.2 you can also freeze the commits of some of the repositories. Last but not least, with tsrc you do everything with tsrc init and tsrc sync , which is a simpler command line API than git submodule . Why not using libgit2 or similar? \u00b6 pygit2 now has pre-built wheels for Windows, but not for macOS and Linux. We prefer to not require compiling libgit2 . Also, we prefer calling git \"porcelain\" commands, both for readability of the source code and ease of debugging. Why do you hide which git commands are run? \u00b6 It's mainly a matter of not cluttering the output. We take care of keeping the output of tsrc both concise, readable and informative. That being said: In case a git command fails, we'll display the full command that was run. If you still need to see all the git commands that are run, we provide a --verbose flag, like so: tsrc --verbose sync Why argparse? \u00b6 See docopt v argparse , and please don't use click . Why YAML? \u00b6 It's nice to read and write, and we use the excellent ruamel.yaml which even has round-trip support. Also, being Python fans, we don't mind the whitespace constraints :P","title":"FAQ"},{"location":"faq/#why_not_python2_support","text":"We believe Python2 is an inferior language than Python3, and we use many Python3 features to make the code more readable and robust. Plus Python2.7 supports ends in 2020 .","title":"Why not Python2 support?"},{"location":"faq/#why_not_repo","text":"We used repo for a while, but found that tsrc had both a better command line API and a nicer output. On a less subjective level: Good support for Windows (no need for CygWin or anything like that) GitLab support (automate working with merge requests) Lastly, tsrc tries hard to never do any destructive operation or unexpected actions. For instance, tsrc never puts you in a \"detached HEAD\" state, nor does automatic rebases. It also never touches dirty repos. This is achieved by using mostly 'porcelain' commands from git, instead of relying on plumbings internals. Also (and this matters a lot if you think about contribution): Comprehensive test suite Uses PEP8 coding style Written in Python 3, not Python 2 Here are a few features present in repo that are missing from tsrc (but may be implemented in the future) Cloning several repositories in parallel Support for other hosting services such as gerrit or github","title":"Why not repo?"},{"location":"faq/#why_not_git-subrepo_mu-repo_or_gr","text":"All this projects are fine but did not match our needs: git-subrepo squashes commits, and we prefer having normal clones everywhere. mu-repo is nice and contains an interesting dependency management feature, but currently we do not need this complexity. In any case, now that the whole team is using tsrc all the time, it's likely we'll keep using tsrc in the future.","title":"Why not git-subrepo, mu-repo, or gr?"},{"location":"faq/#why_not_git_submodule","text":"It's all about workflow. With git-submodule , you have a 'parent' repository and you freeze the state of the 'children' repositories to a specific commit. It's useful when you want to re-build a library you've forked when you build your main project, or when you have a library or build tools you want to factorize across repositories: this means that each 'parent' repository can have its children on any commit they want. With tsrc , all repositories are equal, and what you do instead is to make sure all the branches (or tags) are consistent across repositories. For instance, if you have foo and bar , you are going to make sure the 'master' branch of foo is always compatible to the 'master' branch of bar . Or if you want to go back to the state of the '0.42' release, you will run: tsrc foreach -- git reset --hard v0.42 . Note that since tsrc 0.2 you can also freeze the commits of some of the repositories. Last but not least, with tsrc you do everything with tsrc init and tsrc sync , which is a simpler command line API than git submodule .","title":"Why not git submodule?"},{"location":"faq/#why_not_using_libgit2_or_similar","text":"pygit2 now has pre-built wheels for Windows, but not for macOS and Linux. We prefer to not require compiling libgit2 . Also, we prefer calling git \"porcelain\" commands, both for readability of the source code and ease of debugging.","title":"Why not using libgit2 or similar?"},{"location":"faq/#why_do_you_hide_which_git_commands_are_run","text":"It's mainly a matter of not cluttering the output. We take care of keeping the output of tsrc both concise, readable and informative. That being said: In case a git command fails, we'll display the full command that was run. If you still need to see all the git commands that are run, we provide a --verbose flag, like so: tsrc --verbose sync","title":"Why do you hide which git commands are run?"},{"location":"faq/#why_argparse","text":"See docopt v argparse , and please don't use click .","title":"Why argparse?"},{"location":"faq/#why_yaml","text":"It's nice to read and write, and we use the excellent ruamel.yaml which even has round-trip support. Also, being Python fans, we don't mind the whitespace constraints :P","title":"Why YAML?"},{"location":"guide/basics/","text":"Basic tsrc usage \u00b6 Creating a manifest \u00b6 tsrc is driven by a manifest file that contains the names and paths of repositories to use. It is a YAML file that looks like this: repos: - src: foo url: git@gitlab.local:acme/foo - src: bar url: git@gitlab.local:acme/bar Note The full manifest file format is described in the reference . You can put the manifest in two different places: The recommended way is to put the manifest inside its own git repository, so that changes in the manifest can be tracked like any other code change. The file must be named manifest.yml Alternatively, you can store the manifest in any file on your file system. Cloning a set of repositories \u00b6 Once the manifest is ready, you can run the following commands to create a new workspace: $ mkdir ~/work $ cd work # When the manifest is inside a git repository: $ tsrc init git@gitlab.local:acme/manifest.git # When the manifest is on the file system: $ tsrc init --file /path/to/manifest.yml In this example: If using a git repository, a clone of the manifest repository will be created in a hidden .tsrc/manifest folder. Otherwise, tsrc will write the path of the manifest inside a persistent configuration file. Then foo will be cloned in <work>/foo using git@gitlab.local/acme/foo.git as the origin remote URL. Similarly, bar will be cloned in <work>/bar using git@gitlab.local:acme/bar.git . Making sure all the repositories are up to date \u00b6 You can update all the repositories by using tsrc sync . If tsrc init was called with a git URL, the manifest clone will be updated first. Otherwise, tsrc sync will read its persistent configuration file and read the manifest from the recorded path. This means that if the manifest file path changes, you'll have to re-run tsrc init for tsrc sync to work . If a new repository has been added to the manifest, it will be cloned. Lastly, the other repositories will be updated. Note that tsrc sync only updates the repositories if the changes are trivial: If the branch has diverged, tsrc will do nothing. It's up to you to use rebase or merge . Ditto if there is no remote tracking branch. Note Like git , tsrc will walk up the folders hierarchy looking for a .tsrc folder, which means you can run tsrc commands anywhere in your workspace, not just at the top.","title":"Basic usage"},{"location":"guide/basics/#basic_tsrc_usage","text":"","title":"Basic tsrc usage"},{"location":"guide/basics/#creating_a_manifest","text":"tsrc is driven by a manifest file that contains the names and paths of repositories to use. It is a YAML file that looks like this: repos: - src: foo url: git@gitlab.local:acme/foo - src: bar url: git@gitlab.local:acme/bar Note The full manifest file format is described in the reference . You can put the manifest in two different places: The recommended way is to put the manifest inside its own git repository, so that changes in the manifest can be tracked like any other code change. The file must be named manifest.yml Alternatively, you can store the manifest in any file on your file system.","title":"Creating a manifest"},{"location":"guide/basics/#cloning_a_set_of_repositories","text":"Once the manifest is ready, you can run the following commands to create a new workspace: $ mkdir ~/work $ cd work # When the manifest is inside a git repository: $ tsrc init git@gitlab.local:acme/manifest.git # When the manifest is on the file system: $ tsrc init --file /path/to/manifest.yml In this example: If using a git repository, a clone of the manifest repository will be created in a hidden .tsrc/manifest folder. Otherwise, tsrc will write the path of the manifest inside a persistent configuration file. Then foo will be cloned in <work>/foo using git@gitlab.local/acme/foo.git as the origin remote URL. Similarly, bar will be cloned in <work>/bar using git@gitlab.local:acme/bar.git .","title":"Cloning a set of repositories"},{"location":"guide/basics/#making_sure_all_the_repositories_are_up_to_date","text":"You can update all the repositories by using tsrc sync . If tsrc init was called with a git URL, the manifest clone will be updated first. Otherwise, tsrc sync will read its persistent configuration file and read the manifest from the recorded path. This means that if the manifest file path changes, you'll have to re-run tsrc init for tsrc sync to work . If a new repository has been added to the manifest, it will be cloned. Lastly, the other repositories will be updated. Note that tsrc sync only updates the repositories if the changes are trivial: If the branch has diverged, tsrc will do nothing. It's up to you to use rebase or merge . Ditto if there is no remote tracking branch. Note Like git , tsrc will walk up the folders hierarchy looking for a .tsrc folder, which means you can run tsrc commands anywhere in your workspace, not just at the top.","title":"Making sure all the repositories are up to date"},{"location":"guide/review/","text":"tsrc can automate part of the code review process. You can use it with GitLab, GitHub, GitHub Enterprise, or standard Git repositories. Handling GitLab merge requests \u00b6 Configuration \u00b6 The first step is to log in to GitLab and get your personal access token. Then, write a file in ~/.config/tsrc.yml containing the token: auth: gitlab: token: <your token> Note The full config file format is described in the reference . The second step is to tell tsrc about the HTTP url of your GitLab instance, which is needed to call the GitLab HTTP API (currently using version 4 ). This is done in the manifest file: gitlab: url: http://gitlab.local repos: - ... Creating and accepting merge requests \u00b6 Here's how you can create and assign a merge request: # start working on your branch $ tsrc push [--assignee ASSIGNEE] If ASSIGNEE is set to a valid GitLab username, it will be used to assign the merge request. When the review is done, you can accept it and let GitLab merge the branch once the CI pipeline passes with the following command: $ tsrc push --accept Handling GitHub & GitHub Enterprise pull requests \u00b6 If there is a remote named origin and starting with git@github.com , tsrc will assume you want to use GitHub. Alternatively, if GitHub Enterprise is configured in the manifest file such as: github_enterprise: url: http://github.local repos: - ... and there is a remote named origin which starts with git@github.local (hostname of github_enterprise.url configuration) , tsrc will assume you want to use GitHub Enterprise. Then, the first time you need access to GitHub API, it will ask for your credentials, generate a token and store it in the ~/.config/tsrc.yml file. In the event your GitHub Enterprise instance has a self-signed certificate the trust store can be configured in the ~/.config/tsrc.yml file via: auth: github_enterprise: verify: <path to your crt file e.g. /etc/pki/tls/certs/ca-bundle.crt | false to disable verification> Creating a pull request \u00b6 Here's how to create a pull request and request reviewers: # start working on your branch $ tsrc push [--reviewer REVIEWER] [--assignee ASSIGNEE] Here REVIEWER and ASSIGNEE should be usernames of members of your organization. You can specify the --reviewer option several times, and you can also assign someone to the pull request with the --assignee option. Note tsrc does not work across repositories yet. See issue #73 . Merging or closing a pull request \u00b6 Assuming you are on the correct branch, you can use tsrc to either merge or close the pull request, like so: # Close $ tsrc push --close # Merge $ tsrc push --merge Handling standard Git repositories \u00b6 If tsrc can't determine to use GitLab, GitHub, or GitHub Enterprise it will push the changes to the remote repository without creating any pull requests on the user's behalf.","title":"Automating code review"},{"location":"guide/review/#handling_gitlab_merge_requests","text":"","title":"Handling GitLab merge requests"},{"location":"guide/review/#configuration","text":"The first step is to log in to GitLab and get your personal access token. Then, write a file in ~/.config/tsrc.yml containing the token: auth: gitlab: token: <your token> Note The full config file format is described in the reference . The second step is to tell tsrc about the HTTP url of your GitLab instance, which is needed to call the GitLab HTTP API (currently using version 4 ). This is done in the manifest file: gitlab: url: http://gitlab.local repos: - ...","title":"Configuration"},{"location":"guide/review/#creating_and_accepting_merge_requests","text":"Here's how you can create and assign a merge request: # start working on your branch $ tsrc push [--assignee ASSIGNEE] If ASSIGNEE is set to a valid GitLab username, it will be used to assign the merge request. When the review is done, you can accept it and let GitLab merge the branch once the CI pipeline passes with the following command: $ tsrc push --accept","title":"Creating and accepting merge requests"},{"location":"guide/review/#handling_github_github_enterprise_pull_requests","text":"If there is a remote named origin and starting with git@github.com , tsrc will assume you want to use GitHub. Alternatively, if GitHub Enterprise is configured in the manifest file such as: github_enterprise: url: http://github.local repos: - ... and there is a remote named origin which starts with git@github.local (hostname of github_enterprise.url configuration) , tsrc will assume you want to use GitHub Enterprise. Then, the first time you need access to GitHub API, it will ask for your credentials, generate a token and store it in the ~/.config/tsrc.yml file. In the event your GitHub Enterprise instance has a self-signed certificate the trust store can be configured in the ~/.config/tsrc.yml file via: auth: github_enterprise: verify: <path to your crt file e.g. /etc/pki/tls/certs/ca-bundle.crt | false to disable verification>","title":"Handling GitHub &amp; GitHub Enterprise pull requests"},{"location":"guide/review/#creating_a_pull_request","text":"Here's how to create a pull request and request reviewers: # start working on your branch $ tsrc push [--reviewer REVIEWER] [--assignee ASSIGNEE] Here REVIEWER and ASSIGNEE should be usernames of members of your organization. You can specify the --reviewer option several times, and you can also assign someone to the pull request with the --assignee option. Note tsrc does not work across repositories yet. See issue #73 .","title":"Creating a pull request"},{"location":"guide/review/#merging_or_closing_a_pull_request","text":"Assuming you are on the correct branch, you can use tsrc to either merge or close the pull request, like so: # Close $ tsrc push --close # Merge $ tsrc push --merge","title":"Merging or closing a pull request"},{"location":"guide/review/#handling_standard_git_repositories","text":"If tsrc can't determine to use GitLab, GitHub, or GitHub Enterprise it will push the changes to the remote repository without creating any pull requests on the user's behalf.","title":"Handling standard Git repositories"},{"location":"ref/cli/","text":"Command line usage \u00b6 Important note \u00b6 We use the argparse library to parse command line arguments, so the --help messages are always up-to-date, probably more so than this documentation :) General \u00b6 tsrc uses the same \"subcommand\" pattern as git does. Options common to all commands are placed right before the command name. Options after the command name only apply to this command. For instance: $ tsrc --verbose sync $ tsrc init MANIFEST_URL Global options \u00b6 --verbose show verbose messages -q, --quiet hide everything except errors and warnings --color [always|never|auto] control using color for messages (default 'auto', on if stdout is a terminal) Usage \u00b6 tsrc init MANIFEST_URL [--group GROUP] Initializes a new workspace. MANIFEST_URL should be a git URL containing a valid manifest.yml file. The -g,-group can be used several times to specify which groups to use when cloning repositories. The -s,--shallow can be used to make shallow clone of all repositories. If you want to add or remove a group in your workspace, you can re-run tsrc init . tsrc foreach -- command --opt1 arg1 Runs command --opt1 arg1 in every repository, and report failures at the end. Note the -- token to separate options for command from options for tsrc . tsrc foreach -c 'command --opt1 arg1' Ditto, but uses a shell ( /bin/sh on Linux or macOS, cmd.exe on Windows). tsrc log --from FROM [--to TO] Display a summary of all changes since FROM (should be a tag), to TO (defaulting to master ). Note that if no changes are found, the repository will not be displayed at all. tsrc push [--assignee ASSIGNEE] You should run this from a repository with the correct branch checked out. (The command will fail if you run this while on the master branch or in \"detached HEAD\" mode.) ASSIGNEE is optional and should match the name of an active GitLab user, or a member of your GitHub team. The merge request (or pull request on GitHub) will get created if no other opened merge request with the same branch exists. Otherwise, the existing merge request will be updated. tsrc push [--ready|--wip] (GitLab only) Toggle the WIP: (\"Work In Progress\") prefix for the merge request. tsrc push --accept (GitLab only) Tell GitLab to merge the merge request after the CI has passed. Note that the source branch will get automatically removed. (It should not matter since all the information about the source branch will be found in the merge commit.) tsrc push --merge (GitHub only): Tell GitHub to merge the pull request. tsrc push [--reviewer REVIEWER ...] (GitHub only): Request a reviewer from REVIEWER . Can be specified multiple times. Should be a member of your organization. tsrc status Displays a summary of the status of your workspace: Shows dirty repos Shows repos not on the expected branch tsrc sync Updates all the repositories and shows a summary at the end. tsrc version Displays tsrc version number, along additional data if run from a git clone.","title":"Command line usage"},{"location":"ref/cli/#command_line_usage","text":"","title":"Command line usage"},{"location":"ref/cli/#important_note","text":"We use the argparse library to parse command line arguments, so the --help messages are always up-to-date, probably more so than this documentation :)","title":"Important note"},{"location":"ref/cli/#general","text":"tsrc uses the same \"subcommand\" pattern as git does. Options common to all commands are placed right before the command name. Options after the command name only apply to this command. For instance: $ tsrc --verbose sync $ tsrc init MANIFEST_URL","title":"General"},{"location":"ref/cli/#global_options","text":"--verbose show verbose messages -q, --quiet hide everything except errors and warnings --color [always|never|auto] control using color for messages (default 'auto', on if stdout is a terminal)","title":"Global options"},{"location":"ref/cli/#usage","text":"tsrc init MANIFEST_URL [--group GROUP] Initializes a new workspace. MANIFEST_URL should be a git URL containing a valid manifest.yml file. The -g,-group can be used several times to specify which groups to use when cloning repositories. The -s,--shallow can be used to make shallow clone of all repositories. If you want to add or remove a group in your workspace, you can re-run tsrc init . tsrc foreach -- command --opt1 arg1 Runs command --opt1 arg1 in every repository, and report failures at the end. Note the -- token to separate options for command from options for tsrc . tsrc foreach -c 'command --opt1 arg1' Ditto, but uses a shell ( /bin/sh on Linux or macOS, cmd.exe on Windows). tsrc log --from FROM [--to TO] Display a summary of all changes since FROM (should be a tag), to TO (defaulting to master ). Note that if no changes are found, the repository will not be displayed at all. tsrc push [--assignee ASSIGNEE] You should run this from a repository with the correct branch checked out. (The command will fail if you run this while on the master branch or in \"detached HEAD\" mode.) ASSIGNEE is optional and should match the name of an active GitLab user, or a member of your GitHub team. The merge request (or pull request on GitHub) will get created if no other opened merge request with the same branch exists. Otherwise, the existing merge request will be updated. tsrc push [--ready|--wip] (GitLab only) Toggle the WIP: (\"Work In Progress\") prefix for the merge request. tsrc push --accept (GitLab only) Tell GitLab to merge the merge request after the CI has passed. Note that the source branch will get automatically removed. (It should not matter since all the information about the source branch will be found in the merge commit.) tsrc push --merge (GitHub only): Tell GitHub to merge the pull request. tsrc push [--reviewer REVIEWER ...] (GitHub only): Request a reviewer from REVIEWER . Can be specified multiple times. Should be a member of your organization. tsrc status Displays a summary of the status of your workspace: Shows dirty repos Shows repos not on the expected branch tsrc sync Updates all the repositories and shows a summary at the end. tsrc version Displays tsrc version number, along additional data if run from a git clone.","title":"Usage"},{"location":"ref/formats/","text":"Configuration files formats \u00b6 Unless otherwise noted, all configuration files use YAML syntax. Manifest format \u00b6 The manifest is always parsed as a dictionary. Top fields \u00b6 repos (required): list of repositories to clone gitlab.url (optional): HTTP URL of the GitLab instance github_enterprise.url (optional): HTTP URL of the Github Enterprise instance groups (optional): list of groups repos \u00b6 Each repository is also a dictionary, containing: src (required): relative path of the repository in the workspace Either: url if you just need one remote named origin A list of remotes with a name and url . In that case, the first remote will be used for cloning the repository. branch (optional): The branch to use when cloning the repository (defaults to master ) tag (optional): When running tsrc init : Project will be cloned at the provided tag. When running tsrc sync : If the project is clean, project will be reset to the given tag, else a warning message will be printed. sha1 (optional): When running tsrc init : Project will be cloned, and then reset to the given sha1. When running tsrc sync : If the project is clean, project will be reset to the given sha1, else a warning message will be printed. copy (optional): A list of dictionaries with src and dest key. Here's a full example: repos: - src: foo url: git@gitlab.local:proj1/foo branch: next - src: bar remotes: - name: origin url: git@gitlab.local:proj1/bar - name: upstream url: git@github.com:user/bar branch: master sha1: ad2b68539c78e749a372414165acdf2a1bb68203 - src: app url: git@gitlab.local:proj1/app tag: v0.1 copy: - src: top.cmake dest: CMakeLists.txt - src: .clang-format In this example: First, proj1/foo will be cloned into <workspace>/foo using the next branch. Then, proj1/bar will be cloned into <workspace>/bar using the master branch, and reset to ad2b68539c78e749a372414165acdf2a1bb68203 . Finally: proj1/app will be cloned into <workspace>/app using the v0.1 tag, top.cmake will be copied from proj1/app/top.cmake to <workspace>/CMakeLists.txt , and .clang-format will be copied from proj1/app/ to <workspace>/ . Note that copy only works with files, not directories. groups \u00b6 The groups section lists the groups by name. Each group should have a repos field containing a list of repositories (only repositories defined in the repos section are allowed). The groups can optionally include other groups, with a includes field which should be a list of existing group names. The group named default , if it exists, will be used to know which repositories to clone when using tsrc init and the --group command line argument is not used. Example: repos: - src: a url: .. - src: b url: .. - src: bar url: .. - src: baz url: .. groups: default: repos: [a, b] foo: repos: [bar, baz] includes: [default] $ tsrc init <manifest_url> # Clones a, b $ tsrc init <manifest_url> --group foo # Clones a, b, bar and baz Note that tsrc init records the names of the groups it was invoked with, so that tsrc sync re-uses them later on. This means that if you want to change the groups used, you must re-run tsrc init with the new group list. tsrc.yml format \u00b6 tsrc.yml must be written in XDG_CONFIG_HOME (or ~/.config/ ). We use GitLab authentication with token, like so: auth: gitlab: token: <your token>","title":"Configuration files formats"},{"location":"ref/formats/#configuration_files_formats","text":"Unless otherwise noted, all configuration files use YAML syntax.","title":"Configuration files formats"},{"location":"ref/formats/#manifest_format","text":"The manifest is always parsed as a dictionary.","title":"Manifest format"},{"location":"ref/formats/#top_fields","text":"repos (required): list of repositories to clone gitlab.url (optional): HTTP URL of the GitLab instance github_enterprise.url (optional): HTTP URL of the Github Enterprise instance groups (optional): list of groups","title":"Top fields"},{"location":"ref/formats/#repos","text":"Each repository is also a dictionary, containing: src (required): relative path of the repository in the workspace Either: url if you just need one remote named origin A list of remotes with a name and url . In that case, the first remote will be used for cloning the repository. branch (optional): The branch to use when cloning the repository (defaults to master ) tag (optional): When running tsrc init : Project will be cloned at the provided tag. When running tsrc sync : If the project is clean, project will be reset to the given tag, else a warning message will be printed. sha1 (optional): When running tsrc init : Project will be cloned, and then reset to the given sha1. When running tsrc sync : If the project is clean, project will be reset to the given sha1, else a warning message will be printed. copy (optional): A list of dictionaries with src and dest key. Here's a full example: repos: - src: foo url: git@gitlab.local:proj1/foo branch: next - src: bar remotes: - name: origin url: git@gitlab.local:proj1/bar - name: upstream url: git@github.com:user/bar branch: master sha1: ad2b68539c78e749a372414165acdf2a1bb68203 - src: app url: git@gitlab.local:proj1/app tag: v0.1 copy: - src: top.cmake dest: CMakeLists.txt - src: .clang-format In this example: First, proj1/foo will be cloned into <workspace>/foo using the next branch. Then, proj1/bar will be cloned into <workspace>/bar using the master branch, and reset to ad2b68539c78e749a372414165acdf2a1bb68203 . Finally: proj1/app will be cloned into <workspace>/app using the v0.1 tag, top.cmake will be copied from proj1/app/top.cmake to <workspace>/CMakeLists.txt , and .clang-format will be copied from proj1/app/ to <workspace>/ . Note that copy only works with files, not directories.","title":"repos"},{"location":"ref/formats/#groups","text":"The groups section lists the groups by name. Each group should have a repos field containing a list of repositories (only repositories defined in the repos section are allowed). The groups can optionally include other groups, with a includes field which should be a list of existing group names. The group named default , if it exists, will be used to know which repositories to clone when using tsrc init and the --group command line argument is not used. Example: repos: - src: a url: .. - src: b url: .. - src: bar url: .. - src: baz url: .. groups: default: repos: [a, b] foo: repos: [bar, baz] includes: [default] $ tsrc init <manifest_url> # Clones a, b $ tsrc init <manifest_url> --group foo # Clones a, b, bar and baz Note that tsrc init records the names of the groups it was invoked with, so that tsrc sync re-uses them later on. This means that if you want to change the groups used, you must re-run tsrc init with the new group list.","title":"groups"},{"location":"ref/formats/#tsrcyml_format","text":"tsrc.yml must be written in XDG_CONFIG_HOME (or ~/.config/ ). We use GitLab authentication with token, like so: auth: gitlab: token: <your token>","title":"tsrc.yml format"}]}